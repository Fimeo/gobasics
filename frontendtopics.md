As a Frontend Developer,

Hydration
Partial hydration
Islands architecture
Streaming SSR
Concurrent rendering
Time slicing
Reconciliation algorithm
Fiber architecture
Virtual DOM diffing complexity
Structural sharing
Immutable data patterns
Referential equality
Memoization pitfalls
Stale closure problem
Event loop (macro vs microtasks)
Task starvation
Layout thrashing
Critical rendering path
Render blocking resources
Tree shaking internals
Code splitting strategies
Dynamic import chunking
Module federation
Shadow DOM
Custom Elements lifecycle
Web Components interoperability
Web Workers vs Service Workers
SharedArrayBuffer
Transferable objects
OffscreenCanvas
WebAssembly integration
Browser compositing layers
Paint vs composite vs layout
GPU acceleration in CSS
CSS containment
Subpixel rendering
IntersectionObserver internals
ResizeObserver loop limits
MutationObserver cost
IndexedDB
Service Worker lifecycle traps
Cache invalidation strategies
Stale-while-revalidate
ETag vs Cache-Control
HTTP/3 and QUIC
Priority hints
Preload vs Prefetch vs Preconnect
CORS preflight
SameSite cookie modes
CSRF vs XSS mitigation
Content Security Policy (CSP)
Trusted Types
DOM clobbering
Prototype pollution
Race conditions in UI state
Tearing in concurrent UI
Scheduler priorities
Render waterfalls
Suspense boundaries
Selective hydration
Server components
Edge rendering
Micro-frontend orchestration
Finite state modeling
Event sourcing in frontend
Optimistic UI rollback strategy
Offline conflict resolution
CRDT basics for collaboration
WebRTC
Backpressure in streams API
AbortController
Streaming fetch response handling
Browser memory leak detection
Detached DOM nodes
Garbage collection timing
PerformanceObserver API
Long tasks API
First Input Delay (FID)
Interaction to Next Paint (INP)
Cumulative Layout Shift (CLS)
Largest Contentful Paint (LCP)
Speculative prerendering
Priority inversion in async code
Deterministic rendering
Idempotent UI actions
Accessibility tree
ARIA live regions internals
Pointer events